# 4. 클래스와 객체
## 4.1 객체 지향 언어의 목적

### 1. 절차 지향 프로그래밍과 객체 지향 프로그래밍
>
>* 절차 지향 프로그래밍
>   * 작업 순서 표현
>   * 작업을 함수로 작성한, 함수들의 집합
>   
>* 객체 지향 프로그래밍
>   * 객체들간의 상호 작용으로 표현
>   * 클래스 혹은 객체들의 집합으로 프로그램 작성
>
### 2. 세상 모든 것이 객체
>* TV, 의자, 책, 집, 카메라, 컴퓨터 등 세상 모든 것이 객체다.
>
>* 실세계 객체의 특징
>   * 객체마다 고유한 특성(state)와 행동(behavior)를 가진다.  //그 상태와 연동이 되는 행동
>   * 다른 객체들과 정보를 주고 받는 등, 상호작용을 하면서 존재한다.
>   
>* 컴퓨터 프로그램에서의 객체 사례
>   * 테트리스 게임의 각 블록들
>   * 한글 프로그램의 메뉴나 버튼들
>
### 3. 객체 지향 프로그래밍
>* 실세계의 사물을 프로그램으로 표현하기 위해 객체 개념 도입
>
>* 사물(객체)란?
>   * 구체적 사물 : 사람, 자동차, 램프
>   * 추상적 사물 : 축구, 강의, 직장
>   
>* 객체가 갖는 멤버
>   * 상태(속성) > 필드 > 멤버 변수
>   * 동작 > 메소드 > 멤버 함수
>   
### 4. 객체 지향의 3대 특징 : 캡슐화, 상속, 다형성
>
>* 캡슐화(encapsulation) : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것.
>   * 객체의 본질적인 특징
>      * 외부의 접근으로부터 객체 보호
>   * 내부를 확인하지 않고 겉 껍질만으로도 사용 가능하도록 하는 것.
>   * 관련된 '데이터'와 '알고리즘(코드)'이 하나의 묶음으로 정리되어 있는 것. 
> 
> * 캡슐화와 정보 은닉
>   * 정보 은닉(information hiding) : 객체를 캡슐로 싸서 객체의 내부를 보호하는 것. 즉, 객체의 실제 구현 내용을 외부에 감추는 것이다.
>   
>* 캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것.
>   * 클래스(class) : 객체 모양을 선언한 틀(캡슐화)
>      * 메소드(멤버 함수)와 필드(멤버 변수)는 모두 클래스 내에 구현
>   * 객체
>      * 클래스의 모양대로 생성된 실체(instance)
>      * 객체 내 데이터에 대한 보호, 외부 접근 제한
>         - 객체 외부에서는 비공개 멤버(필드, 메소드)에 직접 접근할 수 없음
>         - 객체 외부에서는 공개된 메소드를 통해 비공개 멤버 접근
>
## 4.2 자바 클래스 만들기(178p)
### 1. 클래스와 객체
>* 클래스 : 객체를 만들어 내기 위한 설계도 혹은 틀  ex)붕어빵기계
>
>* 객체 : 클래스 모양 그대로 생성된 실체  ex)치즈붕어빵, 팥붕어빵, 슈크림붕어빵, ...
>   * 객체를 클래스의 인스턴스(instance)라고 부름
>
### 2. 클래스 구성(180p)
> 그림4-11 첨부할 것
> 
### 3. 객체 생성 및 접근
>* 객체 생성
>  * **반드시 new키워드**를 이용하여 생성
>  
>* **객체 생성 과정**
>   * **객체에 대한 레퍼런스 변수 선언**
>   * **객체 생성**
>      * **클래스 타입 크기의 메모리 할당**
>      * **객체 내 생성자 코드 실행**
>      
>* 객체의 멤버 접근
>  * 객체 레퍼런스 멤버
><pre>
>[그림4-12]
>   public static void main(String args[])
>  {
>     Circle pizza;   //Circle객체에 대한 레퍼런스 변수 pizza 선언
>     pizza = new Circle();   //Circle 객체 생성
>
>     pizza.radius = 10;
>     pizza.name = "자바 피자";
>     double area = pizza.getArea();
>  }
></pre>
>
>* [예제4-1] 183p
>* [예제4-2] 185p
>* [예제4-3] 187p
>* [실습문제 3번] 242p

## 4.3 생성자(186p)
### 1. 생성자의 특징
>* 생성자의 특징
>   * 생성자는 메소드
>   * 생성자 이름은 **클래스 이름과 반드시 동일**
>   * [생성자 여러 개 작성 가능(**오버로딩**)]
>   * [생성자는 new를 통해 객체를 생성할 때, 객체 당 한 번 호출]
>   * 생성자는 **리턴 타입을 지정할 수 없음.**
>   * [생성자의 목적은 객체 초기화]
>   * 생성자는 객체가 생성될 때 반드시 호출
>       * 그러므로 하나 이상 선언되어야 함.
>       * 개발자가 생성자를 작성하지 않았으면 컴파일러가 자동으로 기본 생성자 삽입. //단, 다른 생성자가 없을 때 사용 가능.
>
### 2. 기본 생성자(190p)
>* 기본 생성자(default constructor)
>   * 매개변수 없고 아무 작업없이 단순리턴하는 생성자
>   * 디폴트 생성자라고도 부름
>   
>* 클래스에 생성자가 하나도 선언되지 않은 경우, 컴파일러에 자동으로 삽입 
>
>* 개발자가 클래스에 생성자를 하나라도 작성한 경우
>   * 기본 생성자 자동삽입x
>   * 기본 생성자는 무조건 클래스 안에 자동으로 생성되는게 아님!!!
>
>* [예제4-4] 189p
>* [4장 연습문제 - 실습문제 3번 생성자 포함하여 실습] 242p
>
### 3. this 레퍼런스(192p)
>* 객체 자신에 대한 레퍼런스
>
>* 현재 실행되는 메소드가 속한 객체의 멤버
>
>* 현재 객체의 멤버 변수
>    * 컴파일러에 의해 자동 관리, 개발자는 사용하기만 하면 됨
>    * **this.멤버** 형태로 멤버 사용
>
### 4. this()로 다른 생성자 호출  (195p)
>* this()
>   * 클래스 내의 생성자 호출
>   * 생성자 내에서만 사용 가능
>   * 반드시 생성자 코드의 제일 처음에 수행
>
>* [예제4-5] 195p (예제4-4를 this메소드를 사용하여 바꾼 것.)
>
## 4.5 메소드 활용(204p)
### 1. 메소드 형식
>*
### 2. 메소드 오버로딩(208p)
>* 메소드 오버로딩(Overloading)
>   * 이름이 같은 메소드 작성
>   * **매개변수의 개수나 타입이 서로 다르고**
>   * 리턴 타입은 오버로딩과 관련 없음
>
## 4.6 객체의 소멸과 가비지 컬렉션(210p)
### 1. 객체 소멸
>* new에 의해 할당된 객체 메모리를 자바 가상 기계의 가용 메모리로 되돌려주는 행위

### 2. 자바 응용프로그램에서 임의로 객체 소멸할 수 없음
>* 객체 소멸은 자바 가상 기계의 고유한 역할
>* 자바 개발자에게는 매우 다행스러운 기능
>
### 3. 가비지(garbage)
>* 자바 응용프로그램에서 new로 할당받은 후, 더 이상 사용하지 않게 된 객체나 배열 메모리
>* 참조하는 레퍼런스가 하나도 없는 객체나 배열을 가비지로 판단한다.
>* 왜냐하면 이 객체는 응용프로그램이 더 이상 접근할 수 없기 때문이다.
>* 가비지 컬렉터(garbage collector) : 적절한 시점에 자동으로 수집하여 가용메모리에 반환시킴.(다시 사용할 수 있도록 백업시킴.)
>
>* [4장 실습문제 2번] 241p
>
## 4.7 접근 지정자 이해(215p)
>* 객체의 캡슐화(클래스, 멤버)로 인하여 다른 객체가 접근하도록 할 지, 말지를 지정해야 한다.
>* 클래스 접근 지정
>   * public
>   * 디폴트 클래스
>   
>* 클래스 멤버 접근지정
>   * Public
>   * Private
>   * protected
>   * 디폴트

### 1. 패키지(package) (216p)
>* 서로 관련 있는 클래스 파일들
>* 디렉터리 혹은 폴더 같은 개념
>* 개발자는 클래스 파일들을 여러 패키지에 분산 관리하는 것이 일반적.

### 2. 자바의 4가지 접근 지정자
>* 자바의 4가지 접근 지정자
>   * public, private, protected, 디폴트
>   * public > protected > 디폴트 > private
>
>* 접근 지정자의 목적
>   * 클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
>   * 객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
>       * 접근 지정은 캡슐화에 묶인 보호를 일부 해제할 목적

### 3. 클래스 접근 지정
>* 클래스 접근 지정
>   * 다른 클래스에서 사용하도록 허용할 지 지정
>   * public 클래스
>       * 다른 모든 클래스에게 접근 허용
>   * 디폴트 클래스(접근지정자 생략)
>       * package-private라고도 함
>       * 같은 패키지의 클래스에만 접근 허용
>
### 4. 멤버 접근 지정(218p. 표4-1 참조)
>* public 멤버
>   * 패키지에 관계 없이 모든 클래스에 접근 허용
>   
>* private 멤버
>   * 동일 클래스 내에만 접근 허용
>   * 상속 받은 서브 클래스에서 접근 불가
>
>* protrcted 멤버
>   * 같은 패키지 내의 다른 모든 클래스에게 접근 허용
>   * 상속 받은 서브 클래스는 다른 패키지에 있어도 접근 가능
>
> * 디폴트(default) 멤버
>   * 같은 패키지 내의 다른 클래스에게 접근 허용
>
>![image](https://user-images.githubusercontent.com/86585181/127096754-726f9259-22f7-4b31-a3b5-e258150cd144.png)
>
>* [4장 이론문제 7번](238p)
>* [4장 이론문제 16번](240p)
>
## 4.8 static 멤버
### 1. 눈은 각 사람마다 있고, 공기는 모든 사람이 공유(소유)한다.
>* [그림 4-34]
>
### 2. static 멤버와 non-static 멤버
>* non-static 멤버의 특성
>   * 공간적 특성 - 멤버들은 객체마다 독립적으로 별도 존재
>       * 인스턴스 멤버라고도 부름
>   * 시간적 특성 - 필드와 메소드는 객체 생성 후 비로소 사용 가능
>   * 비공유 특성 - 멤버들은 달느 객체에 의해 공유되지 않고 배타적
>   
>* static 멤버란?
>   * 객체를 생성하지 않고도 사용할 수 있는 멤버
>   * 클래스 당 하나만 생성되는 멤버(클래스 멤버라고도 부름)
>       * 동일한 클래스의 모든 객체들이 공유함
>   * main() 메소드가 실행되기 전에 이미 생성됨.
>   * static 멤버가 포함된 객체를 생성하기 전에도 사용할 수 있다.
>   
>   * 공간적 특성 - static 멤버들은 클래스 당 하나만 생성
>   * 시간적 특성 - static 멤버들은 클래스가 로딩될 때 공간 할당.
>   * 공유의 특성 - static 멤버들은 동일한 클래스의 모든 객체에 의해 공유
>   
>* [표4-2](223p),[그림4-35](225p)
> 
### 3. static의 활용
>* 전역 변수와 전역 함수를 만들 때 활용
>   * 전역 변수나 전역 함수는 static으로 클래스에 작성
>   * 객체생성없이 멤버와 함수를 호출
>   * static멤버를 가진 클래스 사례
>
>* 공유 멤버를 만들고자 할 때 활용
>   * static 으로 선언된 필드나 메소드는, 하나만 생성되어 클래스의 객체들 사이에서 공유됨.
> 
>* **static 메소드는 non-static 멤버 접근할 수 없음**
>   * 객체가 생성되지 않은 상황에서도 static메소드는 실행될 수 있기 때문에, non-static메소드와 필드 사용 불가
>   * 반대로, non-static 메소드는 static 맴버 사용 가능.
>   
>* this 사용 불가
>   * static메소드는 객체가 생성되지 않은 상황에서도 호출이 가능하므로, 현재 객체를 가르키는 this 레퍼런스 사용할 수 없음.
>[4장 이론문제 11번, 12번, 16번](239p)

## 4.9 final 클래스와 메소드
### 1. final클래스 - 클래스 상속 불가
>
### 2. final메소드 - 오버라이딩 불가
>
### 3. final 필드, 상수 선언
>* 상수를 선언할 때 사용 ex) class SharedClass {public static final double PI = 3.14;}
>* 상수 필드는 선언 시에 초기 값을 지정하여야 한다.
>* 상수 필드는 실행 중에 값을 변경할 수 없다.
>
# 5. 상속
## 5.1 상속의 개념(251p)
### 1. 객체 지향의 상속
>* 부모 클래스에 만들어진 필드와 메소드를 자식클래스가 물려받는 것.
>* 상속 선언만 하면, 자식 클래스는 부모 클래스에 만들어진 필드와 메소드를 만들지 않고도 만든 것과 같은 효과를 얻는다.
>* [그림 5-2] & [그림 5-3]
>
### 2. 상속
>* 기존 클래스로부터 필드와 함수를 상속받아서 새로운 클래스를 파생(확장)시키는 메커니즘
>* 기존(부모)코드 + 새로운 메소드+필드 추가
>* 부모 클래스의 메소드를 새롭게 정의 가능(교체 가능)
>* 상세화 가능
>* 장점
>   * 클래스의 간결화 : 멤버의 중복 작성 불필요
>   * 클래스 관리 용이 : 클래스들의 계층적 분류
>   * 소프트웨어 생산성 향상 : 클래스 재사용과 확장 용이
>
### 3. 상속 선언
>* public class Person{}
>* public class Student **extend** Person{} //Person을 상속받는 클래스 Student 선언
>* public class StudentWorker extend Student{}  //Student를 상속받는 클래스 StudentWorker 선언
>
>* 부모클래스 - 슈퍼클래스(super class)
>* 자식클래스 - 서브클래스(sub class)
>* extend 키워드 : 상속을 선언할 때 사용. 확장한다.
>
>* [실습예제 5-1 클래스 상속 만들기 - Point와 ColorPoint 클래스](253p)
>* [그림 5-4](255p)
>* [5장 연습문제 이론 3번](309p)
>
## 5.2 클래스 상속과 객체(252p)

## 5.3 상속과 protected 접근 지정자(258p)(*건너뜀*)
>
## [**5.4 상속과 생성자**]
### 1. 서브클래스와 슈퍼클래스의 생성자 호출 및 실행
>* [그림5-8] (262p)
>
### 2. 서브클래스에서 슈퍼클래스 생성자 선택
>* [그림 5-9] (263p)
>* [그림 5-10. 기본생성자x -> 오류발생] (264p)
>* [그림 5-11. 서브클래스의 매개변수를 가진 생성자의 경우. 정상](265p)
>   * 슈퍼클래스의 기본생성자와 짝을 이룸
>   * super메소드 사용
>   
### 3. super()
>* super()
>   * 서브클래스에서 명시적으로 슈퍼클래스의 생성자를 선택 호출할 때 사용
>   * 사용방식
>       * super(매개변수);
>   * 인자를 이용하여 슈퍼클래스의 적당한 생성자 호출
>   * 반드시 서브 클래스 생성자코드의 제일 첫 라인에 위치하여야 함!
>   
>   * 부모클래스의 내가 원하는 생성자랑 연결시키고 싶을 때 사용(?)
>       * 기본적으로는 무조건 기본생성자랑 연결되기 때문에.
>   
>* **super()를 이용한 예제 (265p)**
>* [예제5-3 super()를 활용한 ColorPoint 작성](267p)
>* [5장 이론문제 1번](315p)
>
## 5.5 업캐스팅과 instanceof 연산자(*건너뜀?*)

## 5.6 [**메소드 오버라이딩(Method Overriding)**](277p)
### 1. 메소드 오버라이딩의 개념
>* 객체지향의 특징인 다형성 의미.
>* **하나의 이름(방법)으로 많은 상황(행동)에 대처하는 기법**
>* 개념적으로 동일한 작업을 하는 멤버 함수들에 똑같은 이름을 부여할 수 있으므로 코드가 간단해진다.
>* 이름은 같으나, 내용은 다름. 하나의 이름(interface)을 만들고, 상속받아서 실제 코드 내용을 다르게 한다.
>
>* **같은 이름의 메소드가 클래스나 객체에  따라 다르게 동작하도록 구현.**
>* 다형성 사례
>   * 메소드 오버로딩 : 같은 이름이지만 다르게 작동하는 여러 메소드
>   * 메소드 오버라이딩 : 슈퍼클래스의 메소드를 서브클래스마다 다르게 구현.(상속관계)
>
### 2. 메소드 오버라이딩 작성방법(277p)
>* **슈퍼클래스의 메소드를 서브클래스에서 재정의**
>   * **슈퍼 클래스 메소드의 이름, 매개변수 타입, 및 개수, 리턴 타입 등 모든 것 동일하게 작성**
>   * 동적 바인딩 발생
>       * 서브 클래스에 오버라이딩된 메소드가 무조건 실행되는 동적 바인딩.
>       * 무조건 서브클래스의 같은 이름의 메소드를 실행.
>       
### 3. 오버라이딩의 기능과 목적
>* 오버라이딩 기능
>   * 수퍼클래스의 선언도니 메소드를, 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 기능
>   
>* 오버라이딩 목적
>   * 다형성 실현
>   * 상속을 통해 '하나의 인터페이스(같은 이름)에 서로 다른 내용 구현'
>       * Line 클래스에서 draw()는 선을 그리고
>       * Circle 클래스에 draw()는 원을 그리고
>[예제5-6 메소드 오버라이딩](288p)
>
## 5.7 추상 클래스(290p)
### 1. 추상 메소드(abstract method)
>* 추상 메소드(abstract method)
>   * 선언되어 있으나, 코드가 **구현되어 있지 않은 메소드 : 껍데기만 있는 메소드**
>   * 키워드 abstract로 선언
>       * public abstract String getName(); //{}가 없음.
>       * public abstract void setName(String s); //{}가 없다.
>   * 추상 메소드는 서브 클래스에서 오버라이딩하여 구현해야 함.
>   * 추상메소드를 한다면, 무조건 서브클래스에서 가져다가 써야 함.
>   
### 2. 추상클래스(abstract class)
>* 추상클래스(abstract class)
>   * 추상클래스는 객체를 생성할 수 없다.
>* [예제5-7 추상클래스의 구현 연습](294~295p)
